# Research: EventSourcingDB vs SQLite for Time Tracking Application

**Date**: 2025-10-31  
**Status**: ? Research Complete

---

## Executive Summary

**RECOMMENDATION: Continue with SQLite + Drizzle ORM. Do NOT adopt EventSourcingDB.**

EventSourcingDB is fundamentally the wrong tool for this application. Your current architecture with SQLite and a temporal configuration table (`config_chronic`) is the correct approach.

---

## What is EventSourcingDB?

EventSourcingDB is a **separate, standalone database server** specifically designed for event sourcing patterns. Key characteristics:

### Architecture
- **Separate service**: Runs as its own database server (like PostgreSQL or MongoDB)
- **Docker-based deployment**: Distributed as a Docker container
- **HTTP API**: Communicates via REST API, not SQL
- **CloudEvents format**: Events must follow the CloudEvents specification
- **Purpose-built**: Designed exclusively for append-only event logs

### Key Features
- Write immutable events to event streams
- Read events chronologically or anti-chronologically
- Query events using EventQL (their custom query language)
- Observe events in real-time (like a message queue)
- Event preconditions (optimistic concurrency control)
- Event schema validation
- Event signing and verification

### Deployment Requirements
- Docker container required
- Separate database server process
- HTTP API endpoint (default port 3000)
- API token authentication
- Additional operational overhead

---

## Analysis: Does This Fit Your Use Case?

### Your Application's Data Patterns

Looking at your architecture, you have:

1. **Configuration data** - User settings that change over time (tracked projects, regular hours, client filters)
2. **Cached calculations** - Pre-computed daily/weekly sums with invalidation
3. **User authentication** - Better-auth managed tables
4. **External API data** - Fetched from Clockify, not generated by your system

### Event Sourcing Fit Analysis

? **Your application does NOT benefit from event sourcing because:**

1. **No domain events being generated**
   - You're not generating business events
   - You're consuming data from Clockify API (external source)
   - Cache calculations are derived state, not events

2. **No event-driven workflows**
   - No commands being processed
   - No event handlers reacting to events
   - No sagas or process managers
   - No event replay scenarios needed

3. **State changes are simple**
   - Configuration changes are just "new value at time X"
   - Temporal table with `validFrom`/`validUntil` handles this perfectly
   - No need to reconstruct state from event log

4. **Caching is computational, not event-based**
   - Cache invalidation is timestamp-based, not event-driven
   - Recalculation is deterministic from Clockify API data
   - No benefit from event replay

---

## Detailed Comparison: EventSourcingDB vs SQLite

### 1. Deployment & Operations

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **Deployment** | Single file, embedded | Separate Docker container |
| **Infrastructure** | None | Docker runtime required |
| **Ports** | None | HTTP port (3000) |
| **Authentication** | N/A (local) | API tokens |
| **Backup** | Copy one file | More complex |
| **Monitoring** | Simple | Additional service to monitor |
| **Development** | Works immediately | Need Docker setup |

**Winner: SQLite** - Zero operational overhead

---

### 2. Data Model Fit

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **Configuration versioning** | ? Temporal table with validFrom/validUntil | ? Would need to model as events (overkill) |
| **Cached calculations** | ? Simple table with invalidatedAt timestamp | ? Not an event sourcing use case |
| **User authentication** | ? Better-auth integration built-in | ? Would need separate database |
| **Relational queries** | ? SQL with joins, indexes | ? EventQL (limited) |
| **Transactions** | ? ACID transactions | ?? Event-based (different model) |

**Winner: SQLite** - Perfect fit for your data model

---

### 3. Query Patterns

#### Your Application Needs:
```sql
-- Get current configuration for user
SELECT * FROM config_chronic 
WHERE userId = ? AND configType = 'tracked_projects'
  AND validFrom <= NOW() 
  AND (validUntil IS NULL OR validUntil > NOW())

-- Get cached daily sum
SELECT * FROM cached_daily_project_sums
WHERE userId = ? AND date = ? AND invalidatedAt IS NULL

-- Get weekly sums with overtime
SELECT * FROM cached_weekly_sums
WHERE userId = ? AND weekStart >= ? AND weekEnd <= ?
```

#### EventSourcingDB Would Require:
```javascript
// Reconstruct state by reading all config change events
for await (const event of client.readEvents('/users/${userId}/config', {
  recursive: false
})) {
  // Manually rebuild state from events
  if (event.type === 'config.tracked_projects.changed') {
    // Apply event to state
  }
}
```

**Winner: SQLite** - Direct queries vs event replay

---

### 4. Integration with Existing Stack

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **Drizzle ORM** | ? Native support | ? Not compatible |
| **Better-auth** | ? Works out of box | ? Incompatible |
| **TanStack Query** | ? Perfect for SQL queries | ?? Would work but awkward |
| **TypeScript** | ? Full type safety via Drizzle | ?? Client SDK available |
| **Migrations** | ? Drizzle Kit | ? Different migration model |

**Winner: SQLite** - Seamless integration

---

### 5. Developer Experience

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **Learning curve** | Low (standard SQL) | High (event sourcing paradigm) |
| **Debugging** | Standard SQL tools | EventQL + event replay |
| **Testing** | Simple (in-memory SQLite) | TestContainers required |
| **Documentation** | Extensive (SQL, Drizzle) | Limited (new product) |
| **Community** | Massive | Small (26 GitHub stars) |

**Winner: SQLite** - Familiar, well-documented

---

### 6. Performance

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **Read performance** | ? Indexed queries, very fast | ? Event replay overhead |
| **Write performance** | ? Direct writes | ?? HTTP API overhead |
| **Latency** | ? Microseconds (local) | ? Network round-trip |
| **Caching** | ? OS-level + query cache | ?? Would need app-level |
| **Scalability** | ?? Single-user limit | ? Designed for scale |

**Winner: SQLite** - For single-user app, local is fastest

---

### 7. Maintenance & Maturity

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **Maturity** | ? SQLite: 23+ years, Drizzle: proven | ?? EventSourcingDB: released 2025 (< 1 year) |
| **Stability** | ? Rock solid | ?? v1.5.0 (still evolving) |
| **Breaking changes** | ? Rare | ?? Possible (new product) |
| **Long-term support** | ? Guaranteed | ? Unknown |
| **Community adoption** | ? Massive | ? Minimal (26 stars) |

**Winner: SQLite** - Battle-tested vs brand new

---

### 8. Cost & Licensing

| Aspect | SQLite + Drizzle | EventSourcingDB |
|--------|------------------|-----------------|
| **License** | ? Public domain (SQLite), MIT (Drizzle) | ? MIT (client SDK) |
| **Database license** | ? Free | ? Unknown (server is separate) |
| **Infrastructure cost** | ? None | ?? Docker resources |
| **Operational cost** | ? None | ?? Monitoring, updates, etc. |

**Winner: SQLite** - Zero cost

---

## When WOULD EventSourcingDB Make Sense?

EventSourcingDB would be appropriate for applications with:

### ? Good Use Cases for EventSourcingDB:
1. **Financial transaction systems** - Every transaction is an immutable event
2. **Audit trail requirements** - Need complete history of all changes
3. **Event-driven microservices** - Services communicate via events
4. **CQRS architectures** - Separate read/write models
5. **Real-time event streaming** - Need to observe events as they happen
6. **Complex domain logic** - State reconstruction from events
7. **Temporal queries** - "What was the state at time X?"
8. **Event replay scenarios** - Rebuild state, test different scenarios

### ? NOT Good for Your Application Because:
- You're querying external API data (Clockify), not generating events
- Configuration changes are simple value updates, not complex state machines
- No need to replay events or rebuild state
- No event-driven workflows or sagas
- No real-time event processing requirements

---

## Your Current Architecture is Correct

Your temporal configuration table approach (`config_chronic`) is **exactly right**:

```typescript
{
  id: string,
  userId: string,
  configType: enum('tracked_projects', 'regular_hours', 'client_filter'),
  value: json,
  validFrom: timestamp,      // When this config became active
  validUntil: timestamp | null, // null = current config
  createdAt: timestamp
}
```

### Why This Works Perfectly:

1. **Simple queries** - Get config at any point in time with a WHERE clause
2. **Easy to understand** - Anyone can read the schema
3. **Efficient** - Index on (userId, configType, validFrom, validUntil)
4. **Flexible** - JSON value field handles different config types
5. **No complexity** - No event replay, no event handlers, no additional services

### Pattern Name: Temporal Table (aka Slowly Changing Dimension Type 2)

This is a well-known database pattern used by:
- Data warehouses (dimensional modeling)
- Audit systems
- Configuration management
- Historical tracking

**You're using the right pattern for the job.**

---

## Alternative: Simple Event Store with SQLite

If you DID want event sourcing benefits (which you don't need), you could build a simple event store using SQLite:

```typescript
// events table
{
  id: string,
  userId: string,
  aggregateType: string, // 'config', 'cache', etc.
  aggregateId: string,
  eventType: string,
  eventData: json,
  timestamp: timestamp,
  version: number
}
```

### Pros:
- Still embedded (no separate service)
- Full control over event structure
- Works with Drizzle ORM
- Can query events with SQL

### Cons:
- You'd have to build event replay logic
- You'd have to build projection logic
- More complexity than you need
- Solves problems you don't have

**Verdict: Don't do this either. Stick with temporal tables.**

---

## Answers to Your Questions

### Question 1: Should I use EventSourcingDB instead of SQLite?

**NO. Absolutely not.**

Reasons:
1. EventSourcingDB is a separate database server (operational overhead)
2. Your application doesn't generate events
3. You don't need event replay or CQRS
4. SQLite + temporal tables perfectly handles your use case
5. EventSourcingDB is very new (< 1 year old, v1.5.0)
6. You'd need to rewrite your entire data layer
7. No compatibility with Better-auth or Drizzle
8. Adds complexity without benefits

---

### Question 2: Do I need both SQLite and EventSourcingDB?

**NO. Using both would be a mistake.**

If you used both:
- ? Two databases to maintain
- ? Two backup strategies
- ? Two connection management patterns
- ? Data synchronization issues
- ? Unclear which is source of truth
- ? Doubled operational complexity

**There's no scenario where using both makes sense for your application.**

---

### Question 3: What are the pros and cons of each?

### SQLite + Drizzle ORM

#### ? Pros:
1. **Embedded** - No separate server, single file database
2. **Zero configuration** - Works out of the box
3. **Mature** - 23+ years of production use
4. **Fast** - Local access, microsecond latency
5. **Simple operations** - Copy file = backup
6. **Full SQL** - All the power of SQL queries, joins, indexes
7. **Excellent tooling** - Drizzle ORM, migrations, type safety
8. **Perfect integration** - Works with Better-auth, TanStack Query
9. **Temporal tables** - Native support for your versioning needs
10. **Large community** - Extensive documentation, examples
11. **Free** - Public domain, no licensing costs
12. **Development speed** - Iterate quickly with migrations

#### ? Cons:
1. **Single-user limitation** - Not suitable for multi-user concurrent access (NOT a problem for your app)
2. **Not distributed** - Can't scale horizontally (NOT a problem for your app)
3. **No built-in replication** - (NOT needed for your app)

---

### EventSourcingDB

#### ? Pros (for event sourcing use cases):
1. **Purpose-built for events** - If you were doing event sourcing
2. **Event replay** - If you needed to rebuild state
3. **Real-time observation** - If you needed event streaming
4. **CloudEvents standard** - If you needed interoperability
5. **Event preconditions** - If you needed optimistic concurrency on events
6. **TypeScript support** - Client SDK available
7. **Event signing** - If you needed cryptographic verification
8. **Multiple language SDKs** - JavaScript, .NET, PHP, Rust, Go

#### ? Cons (especially for your use case):
1. **Wrong abstraction** - Your app doesn't generate domain events
2. **Separate service** - Docker container, HTTP API, additional infrastructure
3. **Operational overhead** - Another service to monitor, backup, update
4. **New/unproven** - Released 2025, v1.5.0, only 26 GitHub stars
5. **Limited ecosystem** - No Drizzle support, incompatible with Better-auth
6. **Learning curve** - Event sourcing is a complex paradigm
7. **No SQL** - EventQL is custom, less powerful than SQL
8. **Development friction** - Docker required even for local dev
9. **Overkill** - Solves problems you don't have
10. **Migration required** - Would need to rewrite entire data layer
11. **Query complexity** - Event replay vs direct queries
12. **No relational queries** - Lose joins, foreign keys, etc.

---

## Implementation Recommendation

### Continue with Your Current Plan:

1. **SQLite + Drizzle ORM** - Keep using it
2. **Temporal configuration table** - Your `config_chronic` design is correct
3. **Cache tables with invalidation** - Simple timestamp-based approach
4. **Better-auth** - Keep using it
5. **TanStack Query** - Perfect for your API integration

### Your Architecture Scores:

- ? **Simplicity**: 10/10 (embedded database, no services)
- ? **Performance**: 10/10 (local access, fast queries)
- ? **Maintainability**: 10/10 (standard SQL, well-documented)
- ? **Fit for purpose**: 10/10 (temporal tables solve your problem)
- ? **Development speed**: 10/10 (iterate quickly)
- ? **Operational complexity**: 10/10 (no ops required)

### EventSourcingDB Would Score:

- ? **Simplicity**: 3/10 (additional service, Docker required)
- ?? **Performance**: 6/10 (HTTP API overhead, event replay)
- ?? **Maintainability**: 4/10 (new product, small community)
- ? **Fit for purpose**: 2/10 (wrong abstraction for your use case)
- ? **Development speed**: 3/10 (event sourcing complexity)
- ? **Operational complexity**: 3/10 (Docker, monitoring, etc.)

---

## Conclusion

Your current architecture is **exactly right** for your application. EventSourcingDB would be:

1. **Overkill** - Too complex for your needs
2. **Wrong tool** - Not an event sourcing use case
3. **More work** - Additional infrastructure and learning curve
4. **Slower development** - More complexity to maintain
5. **Less mature** - Brand new product vs battle-tested SQLite

### Final Recommendation:

**Close the research TODO in your architecture document and move forward with confidence that SQLite + temporal tables is the correct choice.**

Your temporal configuration table pattern is a well-known, proven approach for handling time-based configuration versioning. You don't need event sourcing, and you definitely don't need a separate event sourcing database.

---

## Additional Resources

### SQLite + Temporal Tables
- [Temporal Tables Pattern](https://en.wikipedia.org/wiki/Temporal_database)
- [Slowly Changing Dimensions](https://en.wikipedia.org/wiki/Slowly_changing_dimension)
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [Drizzle ORM Docs](https://orm.drizzle.team/)

### Event Sourcing (for reference)
- [Martin Fowler - Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
- [Microsoft - Event Sourcing Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)
- [EventSourcingDB Docs](https://docs.eventsourcingdb.io/)

### When to Actually Use Event Sourcing
- You're building a financial system
- You need complete audit trails
- You have complex domain logic with state machines
- You're doing CQRS (Command Query Responsibility Segregation)
- You need to replay events for testing or recovery
- You have event-driven microservices

**Your time tracking application needs NONE of these.**

---

## Update Architecture Document

Based on this research, update your `ARCHITECTURE.md`:

```markdown
### 1. Configuration Versioning Approaches

**Status**: ? Decided - Temporal Tables

**Decision**: Use temporal tables with `validFrom`/`validUntil` timestamps in SQLite.

**Rationale**:
- Perfect fit for configuration versioning needs
- Simple SQL queries to get config at any point in time
- Well-known pattern (Slowly Changing Dimension Type 2)
- No additional infrastructure required
- Works seamlessly with Drizzle ORM

**Alternatives Considered**:
- ? Event Sourcing / EventSourcingDB - Overkill for this use case
- ? Temporal Tables - **Selected** - Simple, efficient, proven

**Research**: See RESEARCH-EventSourcingDB-vs-SQLite.md
```

```markdown
### 2. Event Sourcing Pattern for Calculation Management

**Status**: ? Decided - NOT Using Event Sourcing

**Decision**: Use timestamp-based cache invalidation with regular tables.

**Rationale**:
- Application doesn't generate domain events
- Data comes from external API (Clockify)
- Cache invalidation is computational, not event-driven
- Event sourcing adds complexity without benefits

**Research**: See RESEARCH-EventSourcingDB-vs-SQLite.md
```

```markdown
### 3. EventSourcingDB from Thenativeweb

**Status**: ? Decided - NOT Using EventSourcingDB

**Decision**: Continue with SQLite + Drizzle ORM.

**Rationale**:
- EventSourcingDB is a separate database server (operational overhead)
- Application doesn't fit event sourcing patterns
- SQLite + temporal tables perfectly handles requirements
- EventSourcingDB is very new (< 1 year old, v1.5.0)
- No compatibility with Better-auth or Drizzle ORM

**Research**: See RESEARCH-EventSourcingDB-vs-SQLite.md
```

---

_Research completed: 2025-10-31_
